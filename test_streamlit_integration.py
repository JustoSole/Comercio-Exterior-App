#!/usr/bin/env python3
"""
üß™ Test Streamlit Integration - Prueba de Integraci√≥n Completa
============================================================

Script para probar la integraci√≥n completa del sistema mejorado
con la aplicaci√≥n principal de Streamlit.

Simula el flujo completo sin la interfaz gr√°fica usando:
- Nuevo sistema de configuraci√≥n con API keys desde secrets
- Integraci√≥n NCM refinada (IA + Position Matcher)
- Sistema de debug avanzado
- C√°lculo de flete mejorado (a√©reo/mar√≠timo)
- Flujo de entrada manual/URL actualizado

√öltima actualizaci√≥n: 2025-01-21 - Integraci√≥n NCM refinada
"""

import asyncio
import os
import sys
import json
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, Optional

# Configurar variables de entorno para testing
# En testing usamos variables de entorno directas en lugar de secrets de Streamlit
def setup_test_environment():
    """Configurar entorno de testing con API keys"""
    # En testing, usar variables de entorno o archivo de configuraci√≥n
    test_api_keys = {
        "OPENAI_API_KEY": os.getenv("OPENAI_API_KEY", ""),
        "APIFY_API_KEY": os.getenv("APIFY_API_KEY", ""),
        "EASYPOST_API_KEY": os.getenv("EASYPOST_API_KEY", ""),
        "EASYPOST_API_KEY_TEST": os.getenv("EASYPOST_API_KEY_TEST", ""),
        "EASYPOST_WEBHOOK_SECRET": os.getenv("EASYPOST_WEBHOOK_SECRET", "")
    }
    
    # Configurar variables de entorno para compatibilidad con m√≥dulos
    for key, value in test_api_keys.items():
        if value:
            os.environ[key] = value
    
    return test_api_keys

# Configurar entorno de testing
API_KEYS = setup_test_environment()

# Importar m√≥dulos despu√©s de configurar entorno
try:
    from alibaba_scraper import scrape_single_alibaba_product
    from integration_example import IntegratedNCMClassifier  # NUEVO: Usar integraci√≥n NCM
    from import_tax_calculator import calcular_impuestos_importacion
    from product_dimension_estimator import ProductShippingEstimator
    from freight_estimation import load_freight_rates, calculate_air_freight, calculate_sea_freight
    print("‚úÖ Todos los m√≥dulos importados correctamente")
except ImportError as e:
    print(f"‚ùå Error importando m√≥dulos: {e}")
    sys.exit(1)

# Sistema de debug similar al de la app principal
class TestingDebugSystem:
    """Sistema de debug para testing"""
    
    def __init__(self):
        self.debug_logs = []
        self.api_responses = {}
        self.flow_steps = []
        self.current_step = None
    
    def debug_log(self, message, data=None, level="INFO"):
        """Log de debug con timestamp"""
        timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
        log_entry = {
            "timestamp": timestamp,
            "level": level,
            "message": message,
            "data": data,
            "step": self.current_step
        }
        self.debug_logs.append(log_entry)
        print(f"[{timestamp}] {level}: {message}")
        
        if data and level in ["SUCCESS", "ERROR"]:
            print(f"    Data: {str(data)[:200]}...")
    
    def log_flow_step(self, step_name, status="STARTED", data=None):
        """Registrar paso del flujo"""
        timestamp = datetime.now().isoformat()
        step_log = {
            "timestamp": timestamp,
            "step_name": step_name,
            "status": status,
            "data": data
        }
        self.flow_steps.append(step_log)
        
        if status == "STARTED":
            self.current_step = step_name
        elif status in ["SUCCESS", "ERROR", "COMPLETED"]:
            self.current_step = None
        
        print(f"üîÑ Flow Step: {step_name} - {status}")
    
    def log_api_call(self, api_name, request_data, response_data, success=True):
        """Registrar llamada a API"""
        timestamp = datetime.now().isoformat()
        api_log = {
            "timestamp": timestamp,
            "api_name": api_name,
            "success": success,
            "request": request_data,
            "response": response_data
        }
        key = f"{api_name}_{len(self.api_responses)}"
        self.api_responses[key] = api_log
        
        status = "SUCCESS" if success else "ERROR"
        print(f"üåê API Call: {api_name} - {status}")

# Instancia global del sistema de debug
debug_system = TestingDebugSystem()

# URL de prueba
TEST_URL = "https://www.alibaba.com/product-detail/32-inch-smart-tv-led-full_1600798765951.html"

# Archivo de datos NCM para integraci√≥n
NCM_DATA_FILE = "pdf_reader/ncm/resultados_ncm_hybrid/dataset_ncm_HYBRID_FIXED_20250721_175449.csv"

def validate_setup():
    """Validar que las API keys y archivos necesarios est√©n configurados"""
    print("üîç Validando configuraci√≥n del sistema...")
    
    # Validar API keys principales
    required_keys = ["OPENAI_API_KEY", "APIFY_API_KEY"]
    missing_keys = [key for key in required_keys if not API_KEYS.get(key)]
    
    if missing_keys:
        print(f"‚ùå API keys faltantes: {', '.join(missing_keys)}")
        return False
    
    # Validar archivo de datos NCM
    if not Path(NCM_DATA_FILE).exists():
        print(f"‚ùå Archivo de datos NCM no encontrado: {NCM_DATA_FILE}")
        return False
    
    print("‚úÖ Configuraci√≥n validada correctamente")
    return True

def create_mock_product():
    """Crear producto simulado para testing"""
    from collections import namedtuple
    
    ProductInfo = namedtuple('ProductInfo', [
        'title', 'price_low', 'price_high', 'moq', 'place_of_origin', 
        'categories', 'images', 'url', 'brand_name', 'properties', 'raw_data'
    ])
    
    return ProductInfo(
        title="Smart TV LED 32 inch Full HD with WiFi and Remote Control",
        price_low=85.0,
        price_high=120.0,
        moq="1 piece",
        place_of_origin="China",
        categories=["Consumer Electronics", "Television", "LED TV"],
        images=["https://example.com/tv1.jpg", "https://example.com/tv2.jpg"],
        url=TEST_URL,
        brand_name="Samsung",
        properties={
            "Screen Size": "32 inches",
            "Resolution": "1920x1080",
            "Connectivity": "HDMI, WiFi",
            "Smart TV": "Yes"
        },
        raw_data={
            'subject': "Smart TV LED 32 inch Full HD with WiFi and Remote Control",
            'categories': ["Consumer Electronics", "Television", "LED TV"],
            'mediaItems': [{'type': 'image', 'imageUrl': {'big': 'https://example.com/tv1.jpg'}}],
            'productHtmlDescription': 'High quality smart TV with full HD resolution',
            'productBasicProperties': [
                {"name": "Screen Size", "value": "32 inches"},
                {"name": "Resolution", "value": "1920x1080"}
            ]
        }
    )

def validate_and_select_best_image(images_list):
    """Funci√≥n simplificada de validaci√≥n de im√°genes para testing"""
    if not images_list:
        return {
            "selected_url": None,
            "method": "no_images_available",
            "score": 0
        }
    
    # Para testing, simplemente usar la primera imagen
    return {
        "selected_url": images_list[0],
        "method": "testing_mock",
        "score": 85
    }

def create_enhanced_description(product):
    """Crear descripci√≥n mejorada para clasificaci√≥n NCM"""
    description_parts = [product.title]
    
    # Agregar categor√≠as
    if product.categories:
        description_parts.append(f"Categor√≠as: {', '.join(product.categories)}")
    
    # Agregar origen
    if product.place_of_origin:
        description_parts.append(f"Origen: {product.place_of_origin}")
        
    # Agregar marca
    if hasattr(product, 'brand_name') and product.brand_name:
        description_parts.append(f"Marca: {product.brand_name}")
        
    # Agregar rango de precios
    if product.price_low > 0 and product.price_high > 0:
        description_parts.append(f"Rango de precio: ${product.price_low} - ${product.price_high}")
        
    # Agregar MOQ
    if product.moq:
        description_parts.append(f"MOQ: {product.moq}")
        
    # Agregar propiedades relevantes
    if hasattr(product, 'properties') and product.properties:
        relevant_props = []
        for key, value in product.properties.items():
            key_lower = key.lower()
            if any(term in key_lower for term in ['material', 'size', 'weight', 'color', 'type', 'model', 'specification', 'feature', 'capacity', 'function']):
                relevant_props.append(f"{key}: {value}")
        
        if relevant_props:
            description_parts.append(f"Propiedades: {'; '.join(relevant_props[:5])}")
    
    enhanced_description = " | ".join(description_parts)
    debug_system.debug_log("Descripci√≥n mejorada generada", {
        "original_length": len(product.title) if product and product.title else 0,
        "enhanced_length": len(enhanced_description),
        "components": len(description_parts)
    }, level="SUCCESS")
    
    return enhanced_description

def _get_duties_from_integrated_result(integrated_result: Dict[str, Any]) -> float:
    """Extrae derechos de importaci√≥n del resultado integrado"""
    if not integrated_result or not integrated_result.get('success'):
        return 0.0
    
    # Priorizar datos de la recomendaci√≥n final
    final_rec = integrated_result.get('final_recommendation', {})
    fiscal_data = final_rec.get('fiscal_data', {})
    
    if 'aec' in fiscal_data:
        try:
            return float(fiscal_data['aec'])
        except (ValueError, TypeError):
            pass
    
    # Fallback: datos de IA
    ai_classification = integrated_result.get('ai_classification', {})
    tratamiento = ai_classification.get('tratamiento_arancelario', {})
    derechos_str = tratamiento.get('derechos_importacion', '0.0%')
    
    try:
        import re
        cleaned_str = re.sub(r'[^\d.]', '', str(derechos_str))
        if cleaned_str:
            return float(cleaned_str)
    except (ValueError, TypeError):
        debug_system.debug_log(f"No se pudo parsear derechos de importaci√≥n: '{derechos_str}'. Usando 0.0%.", level="WARNING")
    
    return 0.0

async def test_complete_flow():
    """Probar el flujo completo de an√°lisis"""
    print("üöÄ INICIANDO PRUEBA DE FLUJO COMPLETO ACTUALIZADO")
    print(f"‚è∞ {datetime.now().strftime('%H:%M:%S')}")
    print("="*70)
    
    # Validar configuraci√≥n
    if not validate_setup():
        print("‚ùå Configuraci√≥n incompleta")
        return False
    
    debug_system.log_flow_step("INICIO_TEST_COMPLETO", "STARTED")
    
    # === PASO 1: Simular Scraping de Alibaba ===
    print("\nüì± PASO 1: Simulando extracci√≥n de datos de Alibaba")
    debug_system.log_flow_step("SCRAPING_ALIBABA", "STARTED", {"url": TEST_URL})
    
    try:
        # Para testing, usar producto simulado
        product = create_mock_product()
        debug_system.debug_log(f"Producto simulado creado: {product.title[:50]}...", level="SUCCESS")
        debug_system.log_flow_step("SCRAPING_ALIBABA", "SUCCESS", {"title": product.title})
        
        print(f"  ‚úÖ Producto extra√≠do: {product.title[:50]}...")
        print(f"  üí∞ Precio: ${product.price_low} - ${product.price_high}")
        print(f"  üìç Origen: {product.place_of_origin}")
        print(f"  üè∑Ô∏è  Categor√≠as: {', '.join(product.categories)}")
        
    except Exception as e:
        print(f"  ‚ùå Error en scraping: {e}")
        debug_system.log_flow_step("SCRAPING_ALIBABA", "ERROR", {"error": str(e)})
        return False

    # === PASO 2: An√°lisis de dimensiones y peso ===
    print("\nüß† PASO 2: Analizando dimensiones y peso (datos reales + IA)")
    debug_system.log_flow_step("ESTIMACION_DIMENSIONES", "STARTED")
    
    try:
        estimator = ProductShippingEstimator()
        product_dict = product.raw_data if hasattr(product, 'raw_data') else {}
        
        if not product_dict:
            debug_system.debug_log("No raw_data found, reconstructing for estimation", level="WARNING")
            product_dict = {
                'subject': product.title,
                'categories': product.categories,
                'mediaItems': [{'type': 'image', 'imageUrl': {'big': url}} for url in product.images],
                'productHtmlDescription': '',
                'productBasicProperties': []
            }
        
        shipping_info = estimator.get_shipping_details(product_dict)
        debug_system.log_flow_step("ESTIMACION_DIMENSIONES", "SUCCESS", shipping_info)
        
        method = shipping_info.get('method', 'unknown')
        if method == 'extracted_validated':
            debug_system.debug_log("‚úÖ Usando datos reales extra√≠dos", shipping_info, level="SUCCESS")
            print("  üìè Dimensiones y peso extra√≠dos desde datos reales")
        elif method == 'llm_estimated':
            debug_system.debug_log("üß† Usando estimaci√≥n por IA", shipping_info, level="INFO")
            print("  ü§ñ Dimensiones y peso estimados por IA")
        else:
            debug_system.debug_log(f"‚ö†Ô∏è M√©todo de estimaci√≥n: {method}", shipping_info, level="WARNING")
        
        # Mostrar dimensiones estimadas
        dims = shipping_info.get('dimensions_cm', {})
        weight = shipping_info.get('weight_kg', 0)
        print(f"  üìê Dimensiones: {dims.get('length_cm', 'N/A')}x{dims.get('width_cm', 'N/A')}x{dims.get('height_cm', 'N/A')} cm")
        print(f"  ‚öñÔ∏è Peso: {weight:.2f} kg")
        
    except Exception as e:
        print(f"  ‚ö†Ô∏è No se pudieron estimar las dimensiones: {e}")
        debug_system.log_flow_step("ESTIMACION_DIMENSIONES", "WARNING", {"error": str(e)})
        shipping_info = {"method": "failed_fallback", "weight_kg": 5.0, "dimensions_cm": {"length_cm": 50, "width_cm": 30, "height_cm": 15}}

    # === PASO 3: Clasificaci√≥n NCM Integrada (IA + Position Matcher) ===
    print("\nü§ñ PASO 3: Clasificaci√≥n NCM Integrada (IA + Validaci√≥n con Datos Oficiales)")
    debug_system.log_flow_step("CLASIFICACION_NCM_INTEGRADA", "STARTED")
    
    try:
        # Inicializar clasificador integrado
        integrated_classifier = IntegratedNCMClassifier(
            ncm_data_file=NCM_DATA_FILE,
            openai_api_key=API_KEYS.get("OPENAI_API_KEY")
        )
        
        # Crear descripci√≥n mejorada
        enhanced_description = create_enhanced_description(product)
        print(f"  üîç Descripci√≥n: {enhanced_description[:80]}...")
        
        # Seleccionar mejor imagen
        image_selection = validate_and_select_best_image(product.images)
        selected_image = image_selection.get('selected_url')
        
        # Clasificar con integraci√≥n completa
        integrated_result = await integrated_classifier.classify_and_validate(
            description=enhanced_description,
            image_url=selected_image,
            validate_position=True
        )
        
        debug_system.log_api_call("integrated_ncm_classifier", {
            "description": enhanced_description[:100],
            "image_url": selected_image,
            "validate_position": True
        }, integrated_result, integrated_result.get('success', False))
        
        if not integrated_result.get('success'):
            raise ValueError(integrated_result.get('error', 'Error desconocido en clasificaci√≥n integrada'))
        
        debug_system.log_flow_step("CLASIFICACION_NCM_INTEGRADA", "SUCCESS", {
            "ai_ncm": integrated_result.get('ncm_from_ai'),
            "validation_type": integrated_result.get('validation', {}).get('match_type'),
            "final_ncm": integrated_result.get('final_recommendation', {}).get('recommended_ncm')
        })
        
        # Mostrar resultados detallados
        ai_ncm = integrated_result.get('ncm_from_ai', 'N/A')
        validation = integrated_result.get('validation', {})
        final_rec = integrated_result.get('final_recommendation', {})
        
        print(f"  ü§ñ IA clasific√≥ como: {ai_ncm}")
        print(f"  üîç Validaci√≥n: {validation.get('match_type', 'N/A')}")
        print(f"  üìã NCM Final: {final_rec.get('recommended_ncm', 'N/A')}")
        print(f"  üéØ Confianza: {final_rec.get('confidence', 'N/A')}")
        print(f"  üìä Fuente: {final_rec.get('source', 'N/A')}")
        
        # Mostrar datos fiscales si est√°n disponibles
        fiscal_data = final_rec.get('fiscal_data', {})
        if fiscal_data:
            aec = fiscal_data.get('aec', 'N/A')
            iva = fiscal_data.get('iva', 'N/A')
            print(f"  üí∞ AEC: {aec}% | IVA: {iva}%")
        
        # Mostrar intervenciones
        interventions = final_rec.get('interventions', [])
        if interventions:
            print(f"  üèõÔ∏è Intervenciones: {', '.join(interventions)}")
        else:
            print(f"  üèõÔ∏è Intervenciones: Ninguna")
        
        # R√©gimen simplificado
        simplified_regime = final_rec.get('simplified_regime', {})
        regime_decision = simplified_regime.get('aplica_final', simplified_regime.get('aplica', 'N/A'))
        print(f"  üöö R√©gimen Simplificado: {regime_decision}")
        
    except Exception as e:
        print(f"  ‚ùå Error en clasificaci√≥n NCM integrada: {e}")
        debug_system.log_flow_step("CLASIFICACION_NCM_INTEGRADA", "ERROR", {"error": str(e)})
        return False

    # === PASO 4: C√°lculo de impuestos ===
    print("\nüí∞ PASO 4: Calculando impuestos argentinos")
    debug_system.log_flow_step("CALCULO_IMPUESTOS", "STARTED")
    
    try:
        precio_promedio = (product.price_low + product.price_high) / 2
        derechos_importacion_pct = _get_duties_from_integrated_result(integrated_result)
        
        tax_result = calcular_impuestos_importacion(
            cif_value=precio_promedio,
            tipo_importador="responsable_inscripto",
            destino="reventa", 
            origen="extrazona",
            tipo_dolar="oficial",
            provincia="CABA",
            derechos_importacion_pct=derechos_importacion_pct
        )
        
        debug_system.log_flow_step("CALCULO_IMPUESTOS", "SUCCESS", {
            "cif_value": precio_promedio,
            "derechos_pct": derechos_importacion_pct,
            "total_impuestos": float(tax_result.total_impuestos)
        })
        
        print(f"  ‚úÖ Impuestos calculados: ${float(tax_result.total_impuestos):.2f}")
        print(f"  üìä Incidencia: {float(tax_result.incidencia_porcentual):.1f}%")
        print(f"  üíé AEC aplicado: {derechos_importacion_pct:.1f}%")
        
    except Exception as e:
        print(f"  ‚ùå Error calculando impuestos: {e}")
        debug_system.log_flow_step("CALCULO_IMPUESTOS", "ERROR", {"error": str(e)})
        return False

    # === PASO 5: C√°lculo de flete mejorado ===
    print("\nüöö PASO 5: Calculando flete internacional")
    debug_system.log_flow_step("CALCULO_FLETE", "STARTED")
    
    try:
        # Cargar tarifas de flete
        freight_rates = load_freight_rates('pdf_reader/extracted_tables.csv')
        
        # Parametros del env√≠o
        import_quantity = 5  # Cantidad de ejemplo
        peso_unitario_kg = shipping_info.get('weight_kg', 5.0)
        dims = shipping_info.get('dimensions_cm', {})
        
        # C√°lculo para ambos tipos de flete
        print(f"  üì¶ Cantidad: {import_quantity} unidades")
        print(f"  ‚öñÔ∏è Peso unitario: {peso_unitario_kg:.2f} kg")
        
        # Flete a√©reo (Courier)
        peso_total_kg = peso_unitario_kg * import_quantity
        if freight_rates is not None:
            flete_aereo_total = calculate_air_freight(peso_total_kg, freight_rates)
        else:
            flete_aereo_total = precio_promedio * import_quantity * 0.15
        flete_aereo_unitario = flete_aereo_total / import_quantity
        
        print(f"  ‚úàÔ∏è Flete A√©reo: ${flete_aereo_total:.2f} total (${flete_aereo_unitario:.2f}/unidad)")
        
        # Flete mar√≠timo (Contenedor)
        if all(d > 0 for d in dims.values()):
            volumen_unitario_cbm = (dims.get('length_cm', 0) * dims.get('width_cm', 0) * dims.get('height_cm', 0)) / 1_000_000
            volumen_total_cbm = volumen_unitario_cbm * import_quantity
            flete_maritimo_total = calculate_sea_freight(volumen_total_cbm)
            flete_maritimo_unitario = flete_maritimo_total / import_quantity
            
            print(f"  üö¢ Flete Mar√≠timo: ${flete_maritimo_total:.2f} total (${flete_maritimo_unitario:.2f}/unidad)")
            print(f"  üìê Volumen: {volumen_total_cbm:.6f} m¬≥")
        else:
            flete_maritimo_total = precio_promedio * import_quantity * 0.12
            flete_maritimo_unitario = flete_maritimo_total / import_quantity
            print(f"  üö¢ Flete Mar√≠timo (estimado): ${flete_maritimo_total:.2f} total")
        
        # Usar flete a√©reo como principal para el c√°lculo final
        flete_costo_unitario = flete_aereo_unitario
        flete_tipo = "Courier (A√©reo)"
        
        debug_system.log_flow_step("CALCULO_FLETE", "SUCCESS", {
            "peso_total_kg": peso_total_kg,
            "volumen_total_cbm": volumen_total_cbm if all(d > 0 for d in dims.values()) else None,
            "flete_aereo_total": flete_aereo_total,
            "flete_maritimo_total": flete_maritimo_total,
            "flete_seleccionado": flete_tipo,
            "costo_unitario": flete_costo_unitario
        })
        
    except Exception as e:
        print(f"  ‚ùå Error calculando flete: {e}")
        debug_system.log_flow_step("CALCULO_FLETE", "ERROR", {"error": str(e)})
        # Usar fallback
        flete_costo_unitario = precio_promedio * 0.15
        flete_tipo = "Estimado (15%)"
        print(f"  üîÑ Usando flete estimado: ${flete_costo_unitario:.2f}/unidad")

    # === PASO 6: C√°lculo de Landed Cost Final ===
    print("\nüéØ PASO 6: C√°lculo Final de Landed Cost")
    debug_system.log_flow_step("CALCULO_FINAL", "STARTED")
    
    try:
        honorarios_despachante = precio_promedio * 0.02
        landed_cost_unitario = precio_promedio + float(tax_result.total_impuestos) + flete_costo_unitario + honorarios_despachante
        
        # C√°lculo total para la cantidad
        costo_total_importacion = landed_cost_unitario * import_quantity
        
        print(f"  üí∞ Precio producto (FOB): ${precio_promedio:.2f}")
        print(f"  üèõÔ∏è Impuestos: ${float(tax_result.total_impuestos):.2f}")
        print(f"  üöö Flete ({flete_tipo}): ${flete_costo_unitario:.2f}")
        print(f"  üë§ Despachante (2%): ${honorarios_despachante:.2f}")
        print(f"  ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        print(f"  üéØ LANDED COST UNITARIO: ${landed_cost_unitario:.2f}")
        print(f"  üì¶ COSTO TOTAL ({import_quantity} unidades): ${costo_total_importacion:.2f}")
        
        markup = ((landed_cost_unitario - precio_promedio) / precio_promedio) * 100
        print(f"  üìà Markup total: {markup:.1f}%")
        
        # An√°lisis de rentabilidad
        print(f"\nüíπ AN√ÅLISIS DE RENTABILIDAD:")
        margenes = [0.3, 0.5, 1.0]  # 30%, 50%, 100%
        cotizacion_ars = 1746.96
        
        for margen in margenes:
            precio_venta_usd = landed_cost_unitario * (1 + margen)
            precio_venta_ars = precio_venta_usd * cotizacion_ars
            utilidad_usd = precio_venta_usd - landed_cost_unitario
            print(f"    Margen {margen:.0%}: ${precio_venta_usd:.2f} USD (${precio_venta_ars:,.0f} ARS) - Utilidad: ${utilidad_usd:.2f}")
        
        debug_system.log_flow_step("CALCULO_FINAL", "SUCCESS", {
            "landed_cost_unitario": landed_cost_unitario,
            "costo_total_importacion": costo_total_importacion,
            "markup_porcentaje": markup,
            "import_quantity": import_quantity
        })
        
    except Exception as e:
        print(f"  ‚ùå Error en c√°lculo final: {e}")
        debug_system.log_flow_step("CALCULO_FINAL", "ERROR", {"error": str(e)})
        return False

    # === PASO 7: Resumen de Integraci√≥n NCM ===
    print("\nüìã PASO 7: Resumen de Integraci√≥n NCM Refinada")
    
    try:
        ai_classification = integrated_result.get('ai_classification', {})
        validation = integrated_result.get('validation', {})
        final_rec = integrated_result.get('final_recommendation', {})
        
        print(f"  ü§ñ Clasificaci√≥n IA:")
        print(f"     NCM: {ai_classification.get('ncm_completo', 'N/A')}")
        print(f"     Confianza: {ai_classification.get('confianza', 'N/A')}")
        print(f"     M√©todo: {ai_classification.get('classification_method', 'N/A')}")
        
        print(f"  üîç Validaci√≥n con Datos Oficiales:")
        print(f"     Tipo de match: {validation.get('match_type', 'N/A')}")
        if validation.get('match_type') == 'exacto':
            position = validation.get('position', {})
            print(f"     Posici√≥n oficial: {position.get('code', 'N/A')}")
            print(f"     Descripci√≥n: {position.get('description', 'N/A')}")
        
        print(f"  üìã Recomendaci√≥n Final:")
        print(f"     NCM recomendado: {final_rec.get('recommended_ncm', 'N/A')}")
        print(f"     Confianza final: {final_rec.get('confidence', 'N/A')}")
        print(f"     Fuente: {final_rec.get('source', 'N/A')}")
        print(f"     Notas: {final_rec.get('notes', 'N/A')}")
        
    except Exception as e:
        print(f"  ‚ö†Ô∏è Error mostrando resumen NCM: {e}")

    print("\n" + "="*70)
    print("üèÅ PRUEBA DE INTEGRACI√ìN COMPLETADA EXITOSAMENTE")
    print(f"‚è∞ {datetime.now().strftime('%H:%M:%S')}")
    print("="*70)
    
    # Resumen final
    print(f"\nüìä RESUMEN FINAL:")
    print(f"  ‚Ä¢ Producto: {product.title[:50]}...")
    print(f"  ‚Ä¢ NCM Final: {final_rec.get('recommended_ncm', 'N/A')}")
    print(f"  ‚Ä¢ Fuente NCM: {final_rec.get('source', 'N/A')}")
    print(f"  ‚Ä¢ Landed Cost: ${landed_cost_unitario:.2f} USD")
    print(f"  ‚Ä¢ Integraci√≥n NCM: ‚úÖ IA + Datos Oficiales")
    print(f"  ‚Ä¢ Sistema de debug: ‚úÖ Activo")
    print(f"  ‚Ä¢ Todos los m√≥dulos: ‚úÖ Funcionando")
    
    debug_system.log_flow_step("TEST_COMPLETO", "COMPLETED")
    
    # Exportar debug logs
    debug_export = {
        "timestamp": datetime.now().isoformat(),
        "test_success": True,
        "debug_logs": debug_system.debug_logs,
        "flow_steps": debug_system.flow_steps,
        "api_responses": debug_system.api_responses,
        "final_result": {
            "landed_cost_unitario": landed_cost_unitario,
            "ncm_integration": integrated_result,
            "shipping_info": shipping_info,
            "tax_calculation": {
                "total_impuestos": float(tax_result.total_impuestos),
                "incidencia": float(tax_result.incidencia_porcentual)
            }
        }
    }
    
    debug_filename = f"debug_integration_test_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    with open(debug_filename, 'w', encoding='utf-8') as f:
        json.dump(debug_export, f, indent=2, ensure_ascii=False, default=str)
    
    print(f"\nüíæ Debug logs exportados: {debug_filename}")
    
    return True

async def test_quick_integration():
    """Test r√°pido de integraci√≥n para validaci√≥n"""
    print("üß™ Test r√°pido de integraci√≥n NCM...")
    
    if not validate_setup():
        return False
    
    try:
        # Test r√°pido del clasificador integrado
        integrated_classifier = IntegratedNCMClassifier(
            ncm_data_file=NCM_DATA_FILE,
            openai_api_key=API_KEYS.get("OPENAI_API_KEY")
        )
        
        # Test con producto simple
        result = await integrated_classifier.classify_and_validate(
            description="televisor LCD 32 pulgadas",
            image_url=None,
            validate_position=True
        )
        
        if result.get('success'):
            final_rec = result.get('final_recommendation', {})
            print(f"‚úÖ Integraci√≥n NCM: {final_rec.get('recommended_ncm', 'N/A')}")
            print(f"‚úÖ Fuente: {final_rec.get('source', 'N/A')}")
            return True
        else:
            print(f"‚ùå Error en integraci√≥n: {result.get('error', 'Error desconocido')}")
            return False
            
    except Exception as e:
        print(f"‚ùå Error en test r√°pido: {e}")
        return False

if __name__ == "__main__":
    """Ejecutar tests"""
    import sys
    
    if len(sys.argv) > 1 and sys.argv[1] == "--quick":
        success = asyncio.run(test_quick_integration())
    else:
        success = asyncio.run(test_complete_flow())
    
    if success:
        print("\nüéâ ¬°SISTEMA DE INTEGRACI√ìN COMPLETAMENTE FUNCIONAL!")
        print("‚úÖ Listo para usar en la aplicaci√≥n Streamlit")
        print("üîß Con integraci√≥n NCM refinada (IA + Position Matcher)")
        print("üìä Sistema de debug avanzado incluido")
    else:
        print("\n‚ùå Hay errores en el sistema de integraci√≥n")
        print("üîß Revisar logs y corregir antes de usar")
        sys.exit(1) 